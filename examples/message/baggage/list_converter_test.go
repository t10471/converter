// Code generated by "encoder -type=List"; DO NOT EDIT.
package baggage

import (
	"bytes"
	"reflect"
	"testing"

	"github.com/t10471/converter/examples/message/creature"
	"github.com/t10471/converter/predefine"
)

func makePlantaeConverter() creature.PlantaeConverter {
	return creature.PlantaeConverter{
		InfoConverter: creature.InfoConverter{Type: [1]byte{0x01}, Detail: [1]byte{0x00}},
		Number:        [2]byte{0x0, 0x05},
		ExtendArea: func() (r [10]byte) {
			copy(r[:], bytes.Repeat([]byte{byte(0)}, 10))
			return
		}(),
	}
}

func makePlantaeConverter10(count int) (r [10]creature.PlantaeConverter) {
	for i := 0; i < 10; i++ {
		if i < count {
			r[i] = makePlantaeConverter()
		} else {
			r[i] = creature.PlantaeConverter{}
		}
	}
	return
}

func makePlantae() creature.Plantae {
	return creature.Plantae{
		Info:       creature.Info{Type: creature.TypePlantae, Detail: creature.DetailPlantaeRubiales},
		Number:     5,
		ExtendArea: 10,
	}
}

func makePlantae10(count int) []creature.Plantae {
	r := make([]creature.Plantae, 10)
	for i := 0; i < 10; i++ {
		if i < count {
			r[i] = makePlantae()
		} else {
			r[i] = creature.Plantae{}
		}
	}
	return r
}

func makeAnimaliaConverter() creature.AnimaliaConverter {
	return creature.AnimaliaConverter{
		InfoConverter: creature.InfoConverter{Type: [1]byte{0x02}, Detail: [1]byte{0x11}},
		Name:          [7]byte{0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7},
		Age:           [2]byte{0x0, 0x21},
		ExtendArea: func() (r [10]byte) {
			copy(r[:], bytes.Repeat([]byte{byte(0)}, 10))
			return
		}(),
	}
}

func makeAnimaliaConverter10(count int) (r [10]creature.AnimaliaConverter) {
	for i := 0; i < 10; i++ {
		if i < count {
			r[i] = makeAnimaliaConverter()
		} else {
			r[i] = creature.AnimaliaConverter{}
		}
	}
	return
}

func makeAnimalia() creature.Animalia {
	return creature.Animalia{
		Info:       creature.Info{Type: creature.TypeAnimalia, Detail: creature.DetailAnimaliaAves},
		Name:       "ABCDEFG",
		Age:        33,
		ExtendArea: 10,
	}
}

func makeAnimalia10(count int) []creature.Animalia {
	r := make([]creature.Animalia, 10)
	for i := 0; i < 10; i++ {
		if i < count {
			r[i] = makeAnimalia()
		} else {
			r[i] = creature.Animalia{}
		}
	}
	return r
}

func TestListConverter_MarshalBuffer(t *testing.T) {
	type fields struct {
		Name          [7]byte
		PlantaeCount  [2]byte
		PlantaeList   [10]creature.PlantaeConverter
		AnimaliaCount [2]byte
		AnimaliaList  [10]creature.AnimaliaConverter
		Cost          [7]byte
	}
	tests := []struct {
		name    string
		fields  fields
		want    *bytes.Buffer
		wantErr bool
	}{
		{
			"OK",
			fields{
				[7]byte{0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7},
				[2]byte{0x0, 0x01},
				makePlantaeConverter10(1),
				[2]byte{0x0, 0x02},
				makeAnimaliaConverter10(2),
				func() (r [7]byte) {
					x, _ := predefine.Int2PackedDecimal(15000, 7)
					copy(r[:], x)
					return r
				}(),
			},
			func() *bytes.Buffer {
				buffer := new(bytes.Buffer)
				buffer.Write([]byte{0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7})
				buffer.Write([]byte{0x0, 0x01})

				buffer.Write([]byte{0x01, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x0, 0x02})
				buffer.Write([]byte{0x02, 0x11, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x02, 0x11, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x0c})
				return buffer
			}(),
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cv := &ListConverter{
				Name:          tt.fields.Name,
				PlantaeCount:  tt.fields.PlantaeCount,
				PlantaeList:   tt.fields.PlantaeList,
				AnimaliaCount: tt.fields.AnimaliaCount,
				AnimaliaList:  tt.fields.AnimaliaList,
				Cost:          tt.fields.Cost,
			}
			got, err := cv.MarshalBuffer()
			if (err != nil) != tt.wantErr {
				t.Errorf("ListConverter.MarshalBuffer() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("ListConverter.MarshalBuffer() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestListConverter_UnmarshalBuffer(t *testing.T) {
	type fields struct {
		Name          [7]byte
		PlantaeCount  [2]byte
		PlantaeList   [10]creature.PlantaeConverter
		AnimaliaCount [2]byte
		AnimaliaList  [10]creature.AnimaliaConverter
		Cost          [7]byte
	}
	type args struct {
		buffer *bytes.Buffer
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			"OK",
			fields{
				[7]byte{0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7},
				[2]byte{0x0, 0x01},
				makePlantaeConverter10(1),
				[2]byte{0x0, 0x02},
				makeAnimaliaConverter10(2),
				func() (r [7]byte) {
					x, _ := predefine.Int2PackedDecimal(15000, 7)
					copy(r[:], x)
					return r
				}(),
			},
			func() args {
				buffer := new(bytes.Buffer)
				buffer.Write([]byte{0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7})
				buffer.Write([]byte{0x0, 0x01})

				buffer.Write([]byte{0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x0, 0x02})
				buffer.Write([]byte{0x01, 0x00, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x01, 0x00, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
				buffer.Write([]byte{0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x0c})
				return args{buffer}
			}(),
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cv := &ListConverter{
				Name:          tt.fields.Name,
				PlantaeCount:  tt.fields.PlantaeCount,
				PlantaeList:   tt.fields.PlantaeList,
				AnimaliaCount: tt.fields.AnimaliaCount,
				AnimaliaList:  tt.fields.AnimaliaList,
				Cost:          tt.fields.Cost,
			}
			if err := cv.UnmarshalBuffer(tt.args.buffer); (err != nil) != tt.wantErr {
				t.Errorf("ListConverter.UnmarshalBuffer() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestListConverter_ConvertFrom(t *testing.T) {
	type fields struct {
		Name          [7]byte
		PlantaeCount  [2]byte
		PlantaeList   [10]creature.PlantaeConverter
		AnimaliaCount [2]byte
		AnimaliaList  [10]creature.AnimaliaConverter
		Cost          [7]byte
	}
	type args struct {
		original List
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			"OK",
			fields{
				[7]byte{0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7},
				[2]byte{0x0, 0x01},
				makePlantaeConverter10(1),
				[2]byte{0x0, 0x02},
				makeAnimaliaConverter10(2),
				func() (r [7]byte) {
					x, _ := predefine.Int2PackedDecimal(15000, 7)
					copy(r[:], x)
					return r
				}(),
			},
			args{List{
				"ABCDEFG",
				1,
				makePlantae10(1),
				2,
				makeAnimalia10(2),
				15000,
			}},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cv := &ListConverter{
				Name:          tt.fields.Name,
				PlantaeCount:  tt.fields.PlantaeCount,
				PlantaeList:   tt.fields.PlantaeList,
				AnimaliaCount: tt.fields.AnimaliaCount,
				AnimaliaList:  tt.fields.AnimaliaList,
				Cost:          tt.fields.Cost,
			}
			if err := cv.ConvertFrom(tt.args.original); (err != nil) != tt.wantErr {
				t.Errorf("ListConverter.ConvertFrom() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestListConverter_ToOriginal(t *testing.T) {
	type fields struct {
		Name          [7]byte
		PlantaeCount  [2]byte
		PlantaeList   [10]creature.PlantaeConverter
		AnimaliaCount [2]byte
		AnimaliaList  [10]creature.AnimaliaConverter
		Cost          [7]byte
	}
	tests := []struct {
		name    string
		fields  fields
		want    List
		wantErr bool
	}{
		{
			"OK",
			fields{
				[7]byte{0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7},
				[2]byte{0x0, 0x01},
				makePlantaeConverter10(1),
				[2]byte{0x0, 0x02},
				makeAnimaliaConverter10(2),
				func() (r [7]byte) {
					x, _ := predefine.Int2PackedDecimal(15000, 7)
					copy(r[:], x)
					return r
				}(),
			},
			List{
				"ABCDEFG",
				1,
				[]creature.Plantae{makePlantae()},
				2,
				[]creature.Animalia{makeAnimalia(), makeAnimalia()},
				15000,
			},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cv := &ListConverter{
				Name:          tt.fields.Name,
				PlantaeCount:  tt.fields.PlantaeCount,
				PlantaeList:   tt.fields.PlantaeList,
				AnimaliaCount: tt.fields.AnimaliaCount,
				AnimaliaList:  tt.fields.AnimaliaList,
				Cost:          tt.fields.Cost,
			}
			got, err := cv.ToOriginal()
			if (err != nil) != tt.wantErr {
				t.Errorf("ListConverter.ToOriginal() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("ListConverter.ToOriginal() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_encodeListEbcdic7(t *testing.T) {
	type args struct {
		e predefine.Ebcdic
	}
	tests := []struct {
		name string
		args args
		want [7]byte
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := encodeListEbcdic7(tt.args.e); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("encodeListEbcdic7() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_decodeListEbcdic7(t *testing.T) {
	type args struct {
		b [7]byte
	}
	tests := []struct {
		name string
		args args
		want predefine.Ebcdic
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := decodeListEbcdic7(tt.args.b); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("decodeListEbcdic7() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_encodeListHex2(t *testing.T) {
	type args struct {
		h predefine.Hex
	}
	tests := []struct {
		name string
		args args
		want [2]byte
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := encodeListHex2(tt.args.h); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("encodeListHex2() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_decodeListHex2(t *testing.T) {
	type args struct {
		b [2]byte
	}
	tests := []struct {
		name string
		args args
		want predefine.Hex
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := decodeListHex2(tt.args.b); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("decodeListHex2() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_encodeListPackedDecimal7(t *testing.T) {
	type args struct {
		p predefine.PackedDecimal
	}
	tests := []struct {
		name    string
		args    args
		want    [7]byte
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := encodeListPackedDecimal7(tt.args.p)
			if (err != nil) != tt.wantErr {
				t.Errorf("encodeListPackedDecimal7() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("encodeListPackedDecimal7() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_decodeListPackedDecimal7(t *testing.T) {
	type args struct {
		b [7]byte
	}
	tests := []struct {
		name string
		args args
		want predefine.PackedDecimal
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := decodeListPackedDecimal7(tt.args.b); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("decodeListPackedDecimal7() = %v, want %v", got, tt.want)
			}
		})
	}
}
